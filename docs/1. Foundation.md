# Phase 1: Foundation - Comprehensive Information Sheet

## Overview

Phase 1 establishes the complete Domain-Driven Design infrastructure and implements the first working aggregate (StockItem). This phase creates the foundation that all future development builds upon. The architecture emphasizes clean separation of concerns, type safety, testability, and business rule enforcement.

---

## Architectural Philosophy

### Domain-Driven Design and Clean Architecture

DDD organizes code around business concepts. Clean Architecture separates code into layers:

- **Domain Layer**: Business rules, zero framework dependencies
- **Application Layer**: Use cases and coordination
- **Infrastructure Layer**: Databases, HTTP, external services
- **HTTP Layer**: Express and routing

This isolation means you can swap PostgreSQL for MySQL or Express for Fastify without touching business logic. When requirements change, your core code remains stable.

TypeScript catches type mismatches at compile time—preventing bugs like accidentally passing a PackageId where StockItemId is expected. For DDD systems with many value objects and aggregates, this prevents entire categories of runtime errors.

---

## The Shared Kernel

The Shared Kernel contains reusable domain infrastructure that multiple bounded contexts use.

### ValueObject Base Class

**Purpose**: All value objects in your system inherit from this.

A value object represents something immutable where identity doesn't matter—only the value. Two Quantity objects with value 100 are identical, even if they're different JavaScript objects. This is fundamentally different from entities (like StockItem), where each instance is unique.

**Key Features**:

- **Deep Immutability**: Properties are frozen so they can't be modified. This prevents bugs where code accidentally mutates a value object that's used elsewhere.
- **Value-Based Equality**: Two ValueObjects with identical properties are considered equal. The `equals()` method compares content, not object reference.
- **Validation Hook**: Subclasses override `validate()` to enforce domain rules at construction time. If you try to create `Quantity(-5)`, it throws immediately rather than later causing a bug.
- **Type Safety**: Uses TypeScript generics so each subclass defines its own properties. `StockItemName` has different rules than `Quantity`.

**Why immutability matters**: If value objects could change, they'd be unreliable. Imagine passing a Quantity around your code, it gets modified somewhere, and your calculations are suddenly wrong. Immutability prevents this entire category of bugs.

### Uuid Value Object

**Purpose**: Type-safe globally unique identifiers.

Without this, an `StockItemId` would just be a string. You could accidentally pass a `PackageId` (also a string) to a function expecting `StockItemId`, and TypeScript wouldn't catch it. By creating a distinct Uuid subclass for each aggregate, you get compile-time safety.

**Why extend ValueObject?**: Uuid inherits immutability and validation. When you create `StockItemId.from("invalid")`, validation fails immediately rather than silently creating a broken ID.

### DomainEvent Base Class

**Purpose**: Record everything that happens in the domain.

When StockItem.add() is called, it doesn't just create an aggregate—it records a `StockItemAdded` event. These events are the source of truth for what happened in your system. Other services subscribe to these events and react (logging, projections, notifications).

**Key Features**:

- **Aggregate Association**: Every event knows which aggregate created it (via aggregateId)
- **Timestamp**: When it happened (occurredOn)
- **Type Safety**: Concrete event classes like `StockItemAdded` define what data they carry
- **Immutability**: Events never change. What happened is locked in the past.
- **Serialization**: Events convert to JSON for publishing over message buses

**Why events are critical**: If you only store the current state in database (quantity=50), you've lost information about how you got there. Events preserve the complete history. You can replay events to rebuild state, provide audit trails, and power real-time projections.

### EventBus Interface

**Purpose**: Contract that event publishing implementations must follow.

The interface doesn't care if you use RabbitMQ, Redis, or just in-memory events. It only defines the contract: `publish(events)` and `subscribe(eventClass, handler)`. This means your domain code never depends on RabbitMQ specifically. When phase 2 adds RabbitMQ, the domain code doesn't change.

### AggregateRoot Base Class

**Purpose**: Base class for all aggregates (like StockItem).

An aggregate is a cluster of domain objects that acts as a single unit. All changes to objects in the aggregate go through the aggregate root. Changes to the aggregate generate domain events.

**Key features**:

- **Event Recording**: The `record()` method adds events to an internal list. When StockItem.reserve() is called, it modifies state AND records a StockItemReserved event.
- **Event Pulling**: The `pullDomainEvents()` method extracts recorded events and clears the list. The repository calls this after saving to know which events to publish.

**Why this matters**: The aggregate manages its own consistency. If you try to reserve more than available, the aggregate throws an error before recording an event. The database never sees an invalid state.

---

## The Inventory Context - StockItem Aggregate

The Inventory context manages warehouse stock. StockItem is the main aggregate—it enforces business rules about quantities and reservations.

### Domain Layer

The domain layer contains pure business logic with zero framework dependencies. You can test it without a database.

**StockItemId, StockItemName, Quantity Value Objects**

These wrap primitive types and enforce domain rules:

- StockItemId: Must be valid UUID format
- StockItemName: 1-100 characters
- Quantity: Non-negative integer, max 1 billion

Each one validates at construction time. You can't accidentally create invalid instances. This makes the rest of the code simpler—if you have a Quantity instance, you know it's valid.

**StockItem Aggregate Root**

The aggregate enforces business logic:

```
StockItem.add({id, name, quantity})  →  Creates new item, records StockItemAdded event
item.reserve(quantity)               →  Decreases quantity, records StockItemReserved event
                                        (throws if insufficient stock)
```

The reserve() method is critical: it validates that sufficient stock exists BEFORE modifying state. If validation fails, neither state changes nor an event is recorded. This is atomic consistency.

**StockItemRepository Interface**

Defines the contract for data access:

```
save(stockItem: StockItem): Promise<void>
find(id: StockItemId): Promise<StockItem | null>
findAll(): Promise<StockItem[]>
delete(id: StockItemId): Promise<void>
```

The interface lives in the domain layer but has no implementation. This lets domain code remain independent of database choice.

### Application Layer

The application layer orchestrates the domain layer and infrastructure.

**AddStockCommand**

A data transfer object that carries HTTP request data:

```
{
  id: "550e8400-e29b-41d4-a716-446655440000",
  name: "iPhone 15 Pro",
  quantity: 100
}
```

Commands represent the user's intent in domain language. The command doesn't know about HTTP—it's just data.

**AddStockCommandHandler**

This use case handler orchestrates everything:

1. Converts command primitives to domain value objects (validates UUIDs, names, quantities)
2. Calls StockItem.add() to create the aggregate (which records StockItemAdded event)
3. Calls repository.save() to persist to database
4. Calls eventBus.publish() to broadcast the event
5. Returns (or throws if anything fails)

The handler is the only place that knows about repositories and event buses. Domain logic stays in the domain layer.

### Infrastructure Layer

Infrastructure handles technical concerns: databases, HTTP, external services.

**StockItemEntity**

TypeORM entity that maps to the database table:

```sql
CREATE TABLE stock_items (
  id VARCHAR(36) PRIMARY KEY,
  name VARCHAR(100) NOT NULL,
  quantity INT NOT NULL
)
```

The entity is just a database representation. It has methods to convert to/from domain aggregates:

```
StockItemEntity.fromDomain(stockItem)  →  Converts aggregate to entity (for saving)
entity.toDomain()                       →  Converts entity to aggregate (for loading)
```

This conversion ensures validation happens when reconstructing aggregates. If someone manually inserts invalid data in the database and you try to load it, the value objects' validation catches it.

**TypeOrmStockItemRepository**

Implements the repository interface for PostgreSQL. Key responsibilities:

1. Saves aggregates to database by converting to entities
2. Loads entities and converts back to aggregates
3. Publishes domain events after successful save
4. Handles errors gracefully (if event publishing fails, the save already happened)

The repository is the only code that knows about TypeORM or SQL. Domain code remains database-agnostic.

**AddStockPostController**

Handles HTTP request/response:

1. Validates required fields
2. Converts HTTP JSON to domain command
3. Calls handler.execute()
4. Returns HTTP response

The controller is thin—business logic lives in the handler and domain, not here.

---

## How Components Interact

### Request-to-Response Flow

```
HTTP Request
    ↓
Express Route
    ↓
Controller (validates HTTP input)
    ↓
Command Creation (HTTP → domain command)
    ↓
Handler (orchestrates domain + infrastructure)
    ↓
Domain (creates/modifies aggregates)
    ↓
Repository (persists to database)
    ↓
EventBus (publishes events)
    ↓
HTTP Response
```

**Example: Adding 100 iPhones to stock**

1. POST `/stock-items` with JSON arrives at Express route
2. Controller extracts id, name, quantity from request body
3. Controller validates required fields exist
4. Controller creates `AddStockCommand` with primitives
5. Handler receives command
6. Handler creates `StockItemId.from(id)` - validates UUID format
7. Handler creates `StockItemName.from(name)` - validates length
8. Handler creates `Quantity.from(quantity)` - validates non-negative integer
9. Handler calls `StockItem.add({id, name, quantity})`
10. Aggregate creates instance and records `StockItemAdded` event
11. Handler calls `repository.save(stockItem)`
12. Repository converts aggregate to database entity
13. Repository saves entity to PostgreSQL
14. Repository pulls events from aggregate
15. Repository publishes events to EventBus
16. Handler returns to controller
17. Controller responds with HTTP 201 and the created ID

Each layer has clear responsibilities. The domain layer enforces rules. The application layer coordinates. Infrastructure handles external concerns.

---

## Testing Strategy

### Unit Tests (Domain Layer)

Test domain logic in isolation, no database or HTTP:

- ValueObject tests verify immutability and validation
- Aggregate tests verify business rules (can't reserve more than available)
- Event tests verify serialization

These tests run instantly because they're pure functions. They document business rules.

### Integration Tests (Infrastructure)

Test components working together with real database:

- Repository tests verify entities save/load correctly
- Handler tests verify domain objects flow through layers
- Full request/response cycle with database

These tests use SQLite in-memory for speed, no external services.

### Acceptance Tests (End-to-End)

Test the entire application with HTTP:

- POST `/stock-items` creates items
- GET `/stock-items` retrieves them
- Error cases handled correctly

These validate the complete system works.

---

## Why This Structure?

### Why Separate Value Objects from Entities?

Entities have identity (two StockItems with different IDs are different, even with identical data). Value objects have no identity (Quantity 100 is always the same).

Separating them means:

- Value objects can be reused across aggregates (Quantity used by StockItem and Package)
- Value objects are always immutable (simpler reasoning)
- Entities enforce consistency through their aggregate root

### Why Repository Pattern?

Without repositories, domain code would depend on TypeORM. If you later wanted MongoDB, you'd have to rewrite domain logic. With repositories, you just create a new repository implementation. Domain logic never changes.

### Why Commands?

Commands make intent explicit. `AddStockCommand` clearly states "add stock". The handler coordinates making it happen. This separation of intent from implementation makes the code easier to understand and test.

### Why Domain Events?

Events decouple services. When StockItem is added, it publishes StockItemAdded. Any service can subscribe to this event. If you later add notifications, reports, or analytics, they just subscribe to the same events. The Inventory service doesn't need to know about them.

---

## Technology Choices

### TypeScript

Adds static typing to catch errors at compile time. The cost (compile step, slightly verbose syntax) is worth the benefit (entire categories of bugs prevented).

### Bun

A fast JavaScript runtime and package manager. Faster than Node.js for development. The difference is small but matters for developer experience.

### PostgreSQL

A reliable, ACID-compliant relational database. Good choice for transactional business applications. TypeORM support is excellent.

### Express

Minimal web framework. Doesn't force opinions. You structure your code (not Express dictating it). This lets you implement clean architecture without fighting the framework.

### TypeORM

ORM (Object-Relational Mapping) that feels like TypeScript. Decorators make mapping intuitive. Good migration support.

### Jest

Standard testing framework. Works with TypeScript through ts-jest. Good enough that it's the default choice for most Node.js projects.

---

## Configuration Files

### tsconfig.json

- `strict: true` - Enforces strict type checking (prevents implicit any types)
- ES2020 target - Modern JavaScript features
- Path mapping (`@/` = src/) - Clean imports

### jest.config.js

- `preset: "bun-jest"` - Uses Bun's optimized test runner
- TypeScript support via ts-jest
- Coverage reporting to track what's tested

### .eslintrc.js

- DDD-specific naming rules (PascalCase for classes, camelCase for methods)
- Domain layer strict (no magic numbers, no implicit any)
- Infrastructure layer flexible (technical code is less pure)

---

## What's Delivered at End of Phase 1

- Complete working HTTP API for adding stock items
- Full domain logic with business rule enforcement
- PostgreSQL persistence with TypeORM
- Event sourcing foundation (events recorded)
- 100% test coverage across domain, application, infrastructure
- Type safety from database to HTTP
- Clean architecture with clear layer separation
- Foundation for adding additional aggregates and contexts

This foundation remains unchanged through future phases. Additional aggregates follow the same patterns. New contexts use the same shared kernel.

---

## What Phase 1 Enables

Phase 2 adds RabbitMQ event publishing. The code from Phase 1 doesn't change—just plug in RabbitMQEventBus.

Phase 3 adds Elasticsearch projections. Projections subscribe to domain events (created in Phase 1) and react.

Phase 4 adds Package aggregate. Follows identical patterns from StockItem.

Each phase builds on previous work without requiring changes to earlier code. This is the power of clean architecture and DDD.
