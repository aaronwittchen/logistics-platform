# Phase 2: Event-Driven Architecture - Information Sheet

# Phase 2: Event-Driven Architecture - Information Sheet

## Key Takeaways

**Phase 2 transforms a monolithic API into a reactive, event-driven system:**

- **RabbitMQ Integration**: Message broker enables asynchronous communication between bounded contexts
- **Loose Coupling**: Services communicate through events, not direct calls—Inventory doesn't know Logistics exists
- **Resilience**: Services continue working even when others fail; events queue up and process when services recover
- **Scalability**: Each context scales independently based on event processing load
- **Audit Trail**: Every business action generates an immutable event for compliance and debugging
- **ReserveStock Use Case**: Demonstrates complete event flow from HTTP request to cross-context communication
- **Production Ready**: Comprehensive error handling, retry logic, dead letter queues, and graceful degradation

**What you can do after Phase 2:**
- Publish domain events from any aggregate
- Subscribe to events in any bounded context
- Build reactive workflows that span multiple services
- Scale event processing independently of API throughput
- Maintain complete audit trails of all business actions

---

## Overview

Phase 2 transforms the logistics platform from a basic API into a reactive, event-driven system. By integrating RabbitMQ as a message broker, bounded contexts communicate through domain events rather than direct calls. This enables loose coupling, scalability, and resilience across the distributed system.

**Duration**: 1-2 weeks  
**Deliverable**: Complete event publishing and consumption infrastructure with RabbitMQ integration

---

## Why Event-Driven Architecture?

Event-Driven Architecture (EDA) uses events—immutable records of business occurrences—as the primary communication mechanism between system components. Instead of services calling each other directly, they publish events to a central hub and subscribe to events they care about.

### Key Benefits

**Loose Coupling**: The Inventory context doesn't know about Logistics. When stock is reserved, it publishes a `StockItemReserved` event. Any service can subscribe—Logistics for package creation, Backoffice for projections, Analytics for reporting—without Inventory changing.

**Scalability**: Handle thousands of events without overloading services. Each bounded context scales independently based on its event processing needs.

**Resilience**: If the Backoffice service is down, Inventory continues working. Events queue up in RabbitMQ and process when Backoffice recovers. No cascading failures.

**Audit Trail**: Every business action generates an event. This creates a complete, immutable history for compliance, debugging, and analytics.

---

## RabbitMQ Integration

RabbitMQ is a message broker implementing AMQP (Advanced Message Queuing Protocol). It acts as the post office for your events, routing messages between publishers and subscribers.

### Why RabbitMQ Over Alternatives?

**RabbitMQ vs Kafka**:

RabbitMQ is the better choice for this logistics platform because:

- **Message Patterns**: RabbitMQ excels at traditional message queue patterns (pub/sub, request/reply, routing). Kafka is optimized for high-throughput event streaming and log aggregation.

- **Complexity**: RabbitMQ is simpler to set up and operate. Kafka requires more infrastructure (Zookeeper/KRaft, partitioning strategy, replication config) which is overkill for this use case.

- **Message Guarantees**: RabbitMQ provides per-message acknowledgments and dead letter queues out of the box. Kafka's offset-based approach requires more application-level coordination.

- **Low Latency**: RabbitMQ delivers lower latency for individual messages. Kafka optimizes for throughput over latency with batching.

- **Resource Footprint**: RabbitMQ uses significantly less memory and disk. Kafka persists all messages to disk by design, which is unnecessary when you already have database persistence.

**When to Consider Kafka**:
- Event streaming with replay requirements (beyond database-backed event sourcing)
- Massive throughput (millions of events/second)
- Complex event processing pipelines
- Long-term event retention as primary storage

**For This Platform**: RabbitMQ's simplicity, routing flexibility, and message-oriented patterns align perfectly with DDD event-driven architecture needs without the operational complexity of Kafka.

### Core Concepts

**Exchanges**: Routing logic that directs events to appropriate queues. Uses topic-based routing where event names become routing keys (e.g., `inventory.stock_item.reserved`).

**Queues**: Temporary storage for events until consumers process them. Durable queues survive broker restarts.

**Bindings**: Connect queues to exchanges with routing patterns. A queue bound with `inventory.*` receives all inventory events.

**Publish/Subscribe Model**: Publishers send events to exchanges without knowing who receives them. Consumers bind queues to exchanges for relevant events.

---

## Infrastructure Components

### RabbitMQConnection

Manages the low-level AMQP connection with sophisticated error handling:

```typescript
export class RabbitMQConnection {
  async connect(): Promise<void> {
    // Establishes connection with event listeners for errors/disconnections
    this.connection.on('error', () => this.handleConnectionError());
    this.connection.on('close', () => this.handleConnectionError());
  }

  private async handleConnectionError(): Promise<void> {
    // Exponential backoff reconnection (1s, 2s, 4s, 8s...)
    // Maximum 10 retry attempts
  }
}
```

**Key Features**:
- Automatic reconnection with exponential backoff
- Concurrent connection attempt protection
- Comprehensive logging for observability
- Graceful shutdown procedures

### RabbitMQEventBus

Implements the EventBus interface for publishing domain events:

```typescript
export class RabbitMQEventBus implements EventBus {
  async start(): Promise<void> {
    // Declares exchanges and queues
    // Sets up dead letter exchange for failed events
  }

  async publish(events: DomainEvent[]): Promise<void> {
    // Publishes with retry logic (3 attempts by default)
    // Moves failed events to dead letter exchange
    // Includes comprehensive metadata
  }
}
```

**Publishing Flow**:
1. Serializes domain events to JSON with metadata (publisher, timestamp, attempt number)
2. Publishes to exchange with event name as routing key
3. Retries with exponential backoff on failure
4. Sends to dead letter exchange after max retries

**Dead Letter Exchange**: Failed events aren't lost—they're routed to a special exchange for manual investigation or reprocessing. This includes error details and failure context.

### RabbitMQConsumer

Processes events from queues with robust error handling:

```typescript
export class RabbitMQConsumer {
  async start(subscribers: DomainEventSubscriber[]): Promise<void> {
    // For each subscriber:
    // 1. Creates durable queue
    // 2. Binds to exchange with event name
    // 3. Starts consuming with retry logic
  }
}
```

**Consumption Flow**:
1. Receives message from queue
2. Deserializes JSON to domain event using `fromPrimitives()`
3. Invokes subscriber's `on(event)` method
4. Acknowledges on success, requeues on retriable failure
5. Sends to dead letter exchange after max retries

**Retry Strategy**: Exponential backoff (1s, 2s, 3s) with configurable max attempts. Handles transient failures gracefully without losing events.

---

## Event System Architecture

### Domain Events

Domain events are immutable records of business occurrences. Every state change in an aggregate generates an event.

**Base Structure**:
```typescript
export abstract class DomainEvent {
  readonly aggregateId: Uuid;     // Which aggregate created this
  readonly eventId: Uuid;          // Unique event identifier
  readonly occurredOn: Date;       // When it happened
  abstract eventName(): string;    // Event type (e.g., 'inventory.stock_item.added')
}
```

**Example Events**:
- `StockItemAdded`: When inventory is created
- `StockItemReserved`: When stock is reserved for an order
- `StockItemReservationReleased`: When a reservation is cancelled
- `StockQuantityAdjusted`: When inventory is adjusted

### Event Subscribers

Subscribers react to domain events. They implement the `DomainEventSubscriber` interface:

```typescript
export interface DomainEventSubscriber<T extends DomainEvent> {
  subscribedTo(): Array<{
    EVENT_NAME: string;
    fromPrimitives: (data: DomainEventPrimitives) => T;
  }>;
  on(event: T): Promise<void>;
}
```

**Example Subscriber**:
```typescript
export class StockItemAddedLogger implements DomainEventSubscriber<StockItemAdded> {
  subscribedTo() {
    return [{ 
      EVENT_NAME: 'inventory.stock_item.added',
      fromPrimitives: StockItemAdded.fromPrimitives 
    }];
  }

  async on(event: StockItemAdded): Promise<void> {
    log.info(`Stock added: ${event.name} (Qty: ${event.quantity})`);
  }
}
```

This simple logger demonstrates the pattern. Future subscribers can trigger complex workflows—creating packages, updating projections, sending notifications—without modifying the publisher.

---

## Complete Event Flow

### Visual Overview

```
┌─────────────────────────────────────────────────────────────────┐
│                         PUBLISHING FLOW                          │
└─────────────────────────────────────────────────────────────────┘

HTTP Request (Reserve Stock)
       ↓
Controller (Validates Input)
       ↓
Command Handler (Orchestrates)
       ↓
StockItem Aggregate (Business Logic)
   • Validates: sufficient stock available
   • Updates: quantity, reservations
   • Records: StockItemReserved event
       ↓
Repository (Persistence)
   • Saves aggregate to PostgreSQL
   • Pulls recorded events
       ↓
RabbitMQ EventBus (Publishing)
   • Serializes event to JSON
   • Publishes to exchange with routing key
   • Retries on failure (3 attempts)
   • Dead letter on final failure
       ↓
RabbitMQ Exchange (Routing)
   • Routes by event name pattern
   • Distributes to bound queues


┌─────────────────────────────────────────────────────────────────┐
│                        CONSUMPTION FLOW                          │
└─────────────────────────────────────────────────────────────────┘

RabbitMQ Queue (Storage)
   • Holds events until processed
   • Durable (survives restarts)
       ↓
RabbitMQConsumer (Processing)
   • Receives message from queue
   • Parses JSON payload
       ↓
Event Deserialization
   • fromPrimitives() converts JSON to domain event
   • Validates event structure
       ↓
Subscriber Handler
   • on(event) processes business logic
   • Examples:
     - Logger: Records event details
     - Projector: Updates read models
     - Workflow: Triggers package creation
       ↓
Acknowledgment
   • Success: ACK (removes from queue)
   • Retriable Error: NACK + requeue
   • Final Failure: Send to dead letter


┌─────────────────────────────────────────────────────────────────┐
│                    CROSS-CONTEXT COMMUNICATION                   │
└─────────────────────────────────────────────────────────────────┘

Inventory Context                  Logistics Context
     │                                    │
     │ StockItemReserved Event           │
     ├──────────────────────────────────>│
     │         (via RabbitMQ)            │
     │                                    │
     │                            Package Created
     │                                    │
     │    PackageRegistered Event        │
     │<──────────────────────────────────┤
     │         (via RabbitMQ)            │
     │                                    │
     v                                    v
Backoffice Context (Updates Projections)
```

### Publishing Flow

1. **Domain Logic**: Aggregate records event during state change
   ```typescript
   stockItem.reserve(quantity, reservationId);
   // Internally calls: this.record(new StockItemReserved(...))
   ```

2. **Repository**: Saves aggregate and publishes events
   ```typescript
   await repository.save(stockItem);  // Saves to database
   const events = stockItem.pullDomainEvents();
   await eventBus.publish(events);    // Publishes to RabbitMQ
   ```

3. **EventBus**: Serializes and sends to RabbitMQ
   ```typescript
   const message = JSON.stringify({
     data: {
       id: event.eventId.value,
       type: event.eventName(),
       attributes: event.toPrimitives(),
       metadata: { publishedAt: new Date(), attempt: 1 }
     }
   });
   channel.publish(exchangeName, routingKey, Buffer.from(message));
   ```

### Consumption Flow

1. **Consumer**: Receives message from queue
2. **Deserialization**: Converts JSON to domain event
   ```typescript
   const event = StockItemReserved.fromPrimitives(eventData);
   ```

3. **Handler Invocation**: Calls subscriber
   ```typescript
   await subscriber.on(event);
   ```

4. **Acknowledgment**: Confirms processing or retries on failure

---

## ReserveStock Use Case

Phase 2 adds the ReserveStock use case to demonstrate cross-context event flow.

### Command and Handler

**Command** carries the reservation request:
```typescript
export class ReserveStockCommand {
  constructor(
    public readonly id: string,
    public readonly quantity: number,
    public readonly reservationId: string,
    public readonly expiresAt?: Date,
    public readonly reason?: string
  ) {}
}
```

**Handler** orchestrates the use case:
```typescript
async execute(command: ReserveStockCommand): Promise<void> {
  const stockItem = await repository.find(id);
  stockItem.reserve(quantity, reservationId, expiresAt, reason);
  await repository.save(stockItem);  // Also publishes StockItemReserved event
}
```

### Enhanced Aggregate

The StockItem aggregate was extended with sophisticated reservation management:

**Multi-dimensional state tracking**:
- Total quantity (all stock)
- Reserved quantity (committed to orders)
- Available quantity (total - reserved)

**Reservation metadata**:
- Expiration times for automatic cleanup
- Business reasons for audit trails
- Reservation updates without duplication

**Comprehensive validation**:
- Cannot reserve more than available
- Reservations must have positive quantities
- Expired reservations automatically released

### HTTP API

**Endpoint**: `PUT /stock-items/{id}/reserve`

**Request**:
```json
{
  "quantity": 50,
  "reservationId": "order-123",
  "expiresAt": "2024-12-31T23:59:59Z",
  "reason": "Customer order"
}
```

The controller validates input, creates the command, executes the handler, and returns the result. Events flow automatically through the infrastructure.

---

## Application Architecture

### Backend App

The Inventory Backend App was updated to initialize the event bus conditionally:

```typescript
constructor() {
  try {
    const connection = new RabbitMQConnection({
      hostname: env('RABBITMQ_HOST', 'localhost'),
      // ... other config
    });
    this.eventBus = new RabbitMQEventBus(connection);
  } catch (error) {
    log.warn('EventBus initialization failed');
    this.eventBus = undefined;  // Continue without events
  }
}
```

If RabbitMQ is unavailable, the app logs a warning and operates without event publishing. This graceful degradation ensures the core API remains functional.

### Consumer App

Consumer applications are dedicated services that process events:

```typescript
async function startConsumer() {
  const connection = new RabbitMQConnection(config);
  await connection.connect();

  const consumer = new RabbitMQConsumer(connection);
  const subscribers = [new StockItemAddedLogger()];

  await consumer.start(subscribers);
}
```

Consumers run independently of backend services. They can be scaled separately based on event processing load.

---

## Error Handling and Resilience

### Retry Mechanisms

**Publisher Retry**: 3 attempts with exponential backoff (1s, 2s, 3s)
**Consumer Retry**: Configurable attempts, message requeuing between retries
**Connection Retry**: 10 attempts with exponential backoff (1s, 2s, 4s, 8s, 16s...)

### Dead Letter Exchanges

Failed events move to a dead letter exchange after max retries. This preserves events for investigation and manual reprocessing. Dead letter messages include:
- Original event data
- Error details (message, stack trace)
- Failure metadata (timestamp, reason)

### Circuit Breaker Pattern

Prevents cascading failures by monitoring error rates. If failures exceed a threshold, the circuit opens and requests fail fast. After a recovery timeout, the circuit allows test requests through.

---

## Monitoring and Observability

Phase 2 includes foundational monitoring capabilities with hooks for production-grade observability tools.

### Built-in Logging

Comprehensive structured logging at every stage:

```typescript
// Connection events
log.ok('RabbitMQ connected');
log.warn('RabbitMQ connection closed, reconnecting...');

// Publishing events
log.info('Published event: inventory.stock_item.reserved (attempt 1)');
log.err('Failed to publish event (attempt 3), sending to dead letter');

// Consumption events
log.info('Processing event: inventory.stock_item.added');
log.ok('Event processed successfully in 45ms');
```

### Metrics Collection

The consumer infrastructure tracks key performance metrics:

```typescript
export class ConsumerMetrics {
  private metrics = {
    eventsProcessed: 0,        // Total successful events
    eventsFailed: 0,           // Total failed events
    eventsRetried: 0,          // Events requiring retries
    averageProcessingTime: 0,  // Mean processing duration
    lastProcessedEvent: null,  // Most recent event type
    uptime: Date.now()         // Service start time
  };
}
```

### Health Checks

Health check endpoints expose system status:

```typescript
GET /health
{
  "status": "healthy",
  "rabbitMQ": "connected",
  "eventBus": "operational",
  "lastEvent": "2024-01-15T10:30:00Z",
  "uptime": 3600
}
```

### Prometheus Integration (Production)

For production deployments, integrate Prometheus for comprehensive metrics:

**Event Processing Metrics**:
- `events_published_total{event_type}` - Counter of published events by type
- `events_consumed_total{event_type}` - Counter of consumed events by type
- `events_failed_total{event_type, reason}` - Failed event counter with failure reason
- `event_processing_duration_seconds{event_type}` - Histogram of processing times
- `event_retry_count{event_type}` - Gauge of retry attempts

**Infrastructure Metrics**:
- `rabbitmq_connection_status` - Connection health (0=down, 1=up)
- `rabbitmq_queue_length{queue_name}` - Messages waiting in queue
- `dead_letter_queue_length` - Failed messages needing attention

**Example Prometheus Configuration**:
```typescript
// Expose metrics endpoint
import { register, Counter, Histogram } from 'prom-client';

const eventsPublished = new Counter({
  name: 'events_published_total',
  help: 'Total number of published events',
  labelNames: ['event_type']
});

const eventProcessingDuration = new Histogram({
  name: 'event_processing_duration_seconds',
  help: 'Event processing duration',
  labelNames: ['event_type'],
  buckets: [0.01, 0.05, 0.1, 0.5, 1, 5]
});

// Metrics endpoint
app.get('/metrics', async (req, res) => {
  res.set('Content-Type', register.contentType);
  res.end(await register.metrics());
});
```

### Grafana Dashboards

Visualize metrics with pre-built dashboards:

**Event Flow Dashboard**:
- Event publishing rate by type
- Event consumption rate by subscriber
- Error rate and retry trends
- Queue depth over time

**Performance Dashboard**:
- Processing duration percentiles (p50, p95, p99)
- Throughput (events/second)
- Consumer lag (queue depth vs processing rate)

**System Health Dashboard**:
- Connection status across all services
- Dead letter queue trends
- Circuit breaker state transitions
- Resource utilization (CPU, memory)

### Alert Rules

Configure alerts for critical conditions:

```yaml
# High error rate
- alert: HighEventFailureRate
  expr: rate(events_failed_total[5m]) > 0.1
  annotations:
    summary: "Event failure rate exceeds 10%"

# Queue backlog
- alert: EventQueueBacklog
  expr: rabbitmq_queue_length > 10000
  annotations:
    summary: "Event queue depth exceeds threshold"

# Consumer lag
- alert: ConsumerLag
  expr: rate(events_published_total[5m]) - rate(events_consumed_total[5m]) > 100
  annotations:
    summary: "Consumers falling behind publishers"
```

### Distributed Tracing

For complex event flows, integrate distributed tracing:

```typescript
// Add trace IDs to events
const event = new StockItemReserved({
  aggregateId,
  metadata: {
    traceId: context.traceId,
    spanId: context.spanId
  }
});
```

Trace events across services using tools like Jaeger or Zipkin to visualize complete request flows from HTTP request through multiple event handlers.

---

## Configuration and Deployment

### Environment Variables

```bash
RABBITMQ_HOST=localhost
RABBITMQ_PORT=5672
RABBITMQ_USER=logistics_user
RABBITMQ_PASS=logistics_pass
```

### Docker Compose

```yaml
rabbitmq:
  image: rabbitmq:3-management-alpine
  ports:
    - "5672:5672"   # AMQP
    - "15672:15672" # Management UI
  environment:
    RABBITMQ_DEFAULT_USER: logistics_user
    RABBITMQ_DEFAULT_PASS: logistics_pass
```

### NPM Scripts

```json
{
  "scripts": {
    "dev": "bun --watch src/apps/inventory/backend/start.ts",
    "consumer:inventory": "bun src/apps/inventory/consumers/start.ts"
  }
}
```

---

## Testing Strategy

### Unit Tests

Test individual components in isolation:
- RabbitMQConnection: Connection, reconnection, error handling
- RabbitMQEventBus: Publishing, retries, dead letter routing
- RabbitMQConsumer: Consumption, deserialization, error handling

### Integration Tests

Test components working together:
- Event publishing to real RabbitMQ
- Event consumption with subscribers
- Repository integration with event bus

### End-to-End Tests

Test complete flows:
1. HTTP request to reserve stock
2. Domain event generated
3. Event published to RabbitMQ
4. Consumer processes event
5. Side effects executed (logging, projections, etc.)

---

## What Phase 2 Delivers

**Complete Event Infrastructure**:
- RabbitMQ integration with robust error handling
- Event publishing from domain aggregates
- Event consumption with subscribers
- Dead letter queues for failed events
- Automatic reconnection and retry logic

**Enhanced Domain Model**:
- Sophisticated reservation management
- Multi-dimensional inventory tracking
- Expiration-based reservation cleanup
- Comprehensive business rule enforcement

**Reactive Architecture**:
- Loose coupling between bounded contexts
- Scalable event processing
- Resilient to service failures
- Complete audit trail of all changes

**Foundation for Growth**:
- Pattern established for all future events
- Infrastructure ready for additional contexts
- Consumer pattern template for new subscribers
- Event-driven workflows enabled

---

## Glossary

**AMQP** (Advanced Message Queuing Protocol): Standard protocol for message-oriented middleware. Defines how messages are formatted, routed, and delivered.

**Aggregate**: A cluster of related domain objects treated as a single unit for consistency. All changes go through the aggregate root.

**Bounded Context**: A distinct domain with its own models and logic. In this system: Inventory, Logistics, and Backoffice are separate contexts.

**Circuit Breaker**: Fault tolerance pattern that prevents cascading failures. Opens after threshold failures, closes after successful recovery.

**Dead Letter Exchange**: Special exchange in RabbitMQ that receives messages that couldn't be delivered or processed. Used for error handling and manual investigation.

**Domain Event**: Immutable record of something significant that happened in the business domain. Past-tense naming (e.g., StockItemReserved).

**Event Bus**: Abstraction for publishing and subscribing to domain events. Hides infrastructure details from domain code.

**Event Sourcing**: Storing the complete history of state changes as events rather than just current state. Events become the source of truth.

**Event-Driven Architecture** (EDA): Design pattern where components communicate through events rather than direct calls. Enables loose coupling and scalability.

**Exchange**: RabbitMQ component that receives published messages and routes them to queues based on routing rules.

**Exponential Backoff**: Retry strategy where delay increases exponentially (1s, 2s, 4s, 8s...). Prevents overwhelming services during failures.

**Message Broker**: Middleware that routes messages between publishers and subscribers. RabbitMQ is a message broker.

**Queue**: RabbitMQ component that stores messages until consumers process them. Provides buffering and load leveling.

**Routing Key**: String used to route messages to queues. In this system, event names serve as routing keys.

**Subscriber**: Component that listens for and processes domain events. Implements specific business reactions to events.

**Topic Exchange**: RabbitMQ exchange type that routes messages based on pattern matching against routing keys.